## Билет 09 Исключения — основы 
Автор: Михаил Лопатин


### Предусловия и постусловия конструктора и деструктора, инвариант объекта

 Предусловия и постусловия конструктора и деструктора, инвариант объекта https://www.rsdn.org/article/design/Code_Contracts.xml (начиная со слов Предусловия и постусловия) Далее часть информации с сайта: Для четкого выражения задачи, выполняемой конкретной функцией, с ней связывают два утверждения – предусловие и постусловие. Предусловие определяет условия, которые должны выполняться всякий раз перед вызовом функции, а постусловие определяет свойства, гарантируемые после завершения ее выполнения. Классическим примером предусловий и постусловий могут служить функция извлечения квадратного корня Sqrt или методы добавления и удаления элемента из стека.

Предусловие связывает вызывающий код: определяются условия, при которых вызов метода клиентом легитимен (например, x > 0 для функции Sqrt или Count != 0 для функции Pop класса Stack). При этом обязательства клиента приносят выгоду классу-поставщику, поскольку классу, выполняющему операцию, не нужно заботиться о том, что же делать при нарушении предусловия: возвращать значение по умолчанию или код ошибки, генерировать исключение, сохранять информацию об ошибке в поток ввода-вывода или прерывать выполнение программы.

Постусловие связывает класс: определяются условия, которые должны быть выполнены по завершению операции (класс Stack должен обеспечить увеличение количество элементов на 1 после выполнения функции Push). Здесь выгода клиента (результат выполнения функции) оборачивается обязательствами поставщика (он уже не может не выполнить свои обязательства, коль они прописаны в контракте).

Предусловия и постусловия характеризуют конкретные функции, но не класс в целом. Экземпляры класса часто обладают некоторыми глобальными свойствами, которые должны выполняться после создания объекта и не нарушаться в течение всего времени жизни. Такие свойства носят название инвариантов класса (class invariants). Они определяют более глубокие семантические свойства и ограничения, присущие объектам этого класса.

Такими свойствами могут служить внутренние условия (некоторое поле не равно null или количество элементов неотрицательно) или правила согласованности внутреннего состояния объекта (empty = (count = 0) или deposit_list.total – withdrawals_list.total = balance). Каждое такое условие не связывает конкретные функции, а характеризует объект в каждый устойчивый момент времени.

Инвариант класса должен выполняться после завершения функции создания (конструктора) и между вызовами всех открытых методов. Вполне законно, что некоторая функция в начале своего выполнения разрушает инвариант класса, а перед завершением выполнения – восстанавливает его истинность. При этом выполнение инвариантов должно соблюдаться только между вызовами открытых методов, в то время как закрытые методы могут вызываться в состоянии, в котором инвариант нарушен, и завершать свое выполнение, не восстанавливая его истинность.

Утверждение Inv является корректным инвариантом класса, если и только если оно удовлетворяет следующим двум условиям:

1. Каждый конструктор, применимый к аргументам, удовлетворяющим его предусловию в состоянии, в котором атрибуты имеют значения, установленные по умолчанию, вырабатывает заключительное состояние, гарантирующее выполнение Inv.

2. Каждый открытый метод класса, вызываемый с аргументами в состоянии, удовлетворяющем Inv и предусловию, вырабатывает заключительное состояние, гарантирующее выполнение Inv.

Эта формула корректности означает, что любая функция создания (конструктор), при вызове которой выполняется предусловие, должна создать объект, у которого выполняется постусловие и его инвариант. Во многих языках программирования если не задавать явно функцию создания, то она будет создана за вас компилятором. В этом случае значение объекта по умолчанию (Default) удовлетворяет инварианту класса (Inv).

### Как отличить "ошибки программирования" (undefined behavior, нарушение инвариантов, невозможно предсказать поведение после) и "ошибки окружения" (некорректный ввод пользователя, теоретически можно предсказать и обработать), разные стратегии обработки для двух видов ошибок

1.Ошибки программирования: любой UB, нарушение инварианта (двоичный поиск, состояние класса), нарушения контракта.
```c++
void foo(const char *s) {
    printf("%s\n", s);  // Некорректный s.
}
```
    * Лучше выявлять на стадии тестирования.
    * Обычно видны не сразу, а через какое-то время.
    * Можно пробовать проверять и детектировать (например, vector::at вместо vector::operator[]), но не задетектирует всё (потому что баги) и неясно, что делать после обнаружения (мало в чём можно быть уверенным).
    * Если случилось, то никаких гарантий, all bets are off. Баг в программе точно есть, причём неизвестный, могло упасть где угодно.

2."Ошибки окружения": некорректный ввод пользователя, файл не найден, оборвалось сетевое соединение...

    * Могут произойти независимо от программы.
    * Лучше обрабатывать.
    * Например, клиент Telegram должен быстро работать, даже если сервер внезапно отвалился. Переподключиться? Держать ещё одно соединение в запасе? Надо думать.
    * Не хватило прав доступа — может, наоборот, не сообщать пользователю, зато сообщить администратору.

Бывают пограничные ситуации в разных контекстах.

    * На хороших контестах гарантируется, что ввод корректен.
    * А что если кончился стэк/память/место на диске?
        * Место на диске: можно забить, можно почистить свой собственный кэш.
        * Память: а если при обработке потребуется ещё память?
        * Не удалась запись в файл: могут быть разные требования к чат-клиенту (который может всё скачать с сервера) и самому серверу (которому надо как-то восстанавливаться и централизованно сообщать "жёсткий диск сломался").
    * Нарушен инвариант структуры — проблема. А вот если мы её перед этим считывали по сети, то, может, это попытка взлома и надо залогировать и пропустить запрос.

Про каждую ошибку в программе надо думать:

    * Что случится, когда произойдёт? (не "если")
    * Можно ли с ней сделать что-то разумное?
    
Почти всегда можно залогировать ошибку для разработчика.

    * Уронить процесс целиком. Самое безопасное при ошибках программирования. Хотя тоже может нарушить инварианты (например, файл не до конца записали). Можно ещё перед этим позвонить домой и отправить багрепорт. А потом немедленно упасть, даже если кажется, что всё хорошо.
    * Уронить кусок процесса. Только если не ошибка программирования (хотя в Java/Python с изоляцией получше). Например, мы сервер и порвалось соединение с клиентом.
    * Как-то обработать: например, попробовать другой адрес для подключения к серверу.
    * Сообщить пользователю и попросить что-нибудь сделать: "файл не найден, выберите другой".
        * Важно понимать, что пользователь далеко не всегда что-то может сделать. О каких ошибках и как сообщать пользователю — отдельный вопрос.

Проще и надёжнее всего уронить программу целиком.

Нет серебрянной пули для обработки ошибок: это такая же часть спецификации программы, над которой надо хорошо думать заранее и отдельно реализовывать.

Например, On Error Resume Next писать не надо никогда.

### Примеры обработки разных видов ошибок без исключений: assert, коды возврата

#### C-style, глобальная переменная и возвращаемое значение 

```c++
void read_people() {
    FILE *f = fopen(filename "r");
    if (!f) {  // Не удалось открыть файл — вернули nullptr.
        printf("Unable to open file\n");
        return;
    }
    // ...
    fclose(f);
}
```

Можно попробовать разобраться поподробнее:

    * EAССES — не хватило каких-то прав доступа (на файл, на папку выше, на создание файла в режиме w...). Самое популярное. Пользователю придётся проверять все папки в иерархии, права процесса...
    * EISDIR — попытались открыть папку как файл на запись.

Пример под Linux: int chdir(const char *path). Возвращает 0 или -1, а дальше смотрим в глобальном errno код.

Разумеется, так нельзя вызывать несколько функций подряд (потому что errno затёрлось) и плохо работать с многопоточностью (надо заводить errno на поток).

Бывают костыли вроде perror (вывести на экран последнюю ошибку).

#### C-style, код ошибки

```c++
int sqlite3_open(
  const char *filename,   /* Database filename (UTF-8) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */
);
```

Функция сразу возвращает код ошибки. А возвращаемое значение пишет по указателю.

Всё ещё надо проверять и не очень удобно.

### Исключения: try, catch, throw (синтаксис, и для новых исключений, и для перебрасывания "текущего"), где что ставить для обработки ошибок

Призваны решить следующие проблемы кодов возврата:

    * Захламляется код, даже если мы не умеем обрабатывать ошибку.
    * Перемешаны happy path/sad path.

Идея:

    * В месте возникновения "кидаем" исключение throw:
    * В промежуточных функциях ничего не делаем
    * Там, где понимаем, что можно сделать, ловим и обрабатываем.

```c++
struct invalid_vector_format {};
std::vector<int> readVector() {
    int n;
    if (!(cin >> n)) {
        throw invalid_vector_format();
    }
    std::vector<int> result(n); // может кинуть исключение.
    for (int i = 0; i < n; i++) {
        if (!(cin >> result[i])) {
            throw invalid_vector_format(); // кинул исключение, знаем, что кто-нибудь поймает.
        }
    }
    return result;
}
void solve() {
    std::vector<int> a = readVector();
    std::vector<int> b = readVector();  // исключение пролетело насквозь
    // вычисления
    writeAnswer(answer);
}
int main() {
    try {
        char *x = malloc(10);
        solve(); // исключение пролетело насквозь
        free(x);
    } catch (invalid_vector_format &err) {
        printf("Invalid vector format: %s\n", err.what());
    }
}
```

### Вложенные try/catch, несколько catch подряд и почему важно ловить по ссылке

```c++
try {
    // вызвали функцию, в которой
    try {
        throw Bar();
    } catch (Foo &err) {
    }
} catch (Bar &err) {
}
```

Проверяется от внутренних к внешним (в том числе сквозь стэк) и в каждом try пробуем за'bind'ить сверху вниз.

Если внутри catch исключение, то оно вылетает во внешний try.


    * Ловят всегда по ссылке, потому что активно используется иерархия и мы не хотим слайсинг. Синтаксис в catch — просто инициализация (как переменная/параметр).
    * Кидают объекты из отдельной иерархии (чтобы можно быть ловить по типу однозначно), причём выделенные "на стеке" (не в куче).
    * Исключения конкретно в C++ предназначены для обработки исключительных ситуаций, которые возникают редко. Компилиторы оптимизируются под happy path, а переключение на sad path может очень сильно тормозить.


### Stack unwinding (раскрутка стэка) и уничтожение локальных ресурсов

```c++
struct invalid_vector_format {};
std::vector<int> readVector() {
    int n;
    if (!(cin >> n)) {
        throw invalid_vector_format();
    }
    std::vector<int> result(n); // может кинуть исключение.
    for (int i = 0; i < n; i++) {
        if (!(cin >> result[i])) {
            throw invalid_vector_format(); // кинул исключение, знаем, что кто-нибудь поймает.
        }
    }
    return result;
}
void solve() {
    std::vector<int> a = readVector();
    std::vector<int> b = readVector();  // исключение пролетело насквозь
    // вычисления
    writeAnswer(answer);
}
int main() {
    try {
        char *x = malloc(10);
        solve(); // исключение пролетело насквозь
        free(x);
    } catch (invalid_vector_format &err) {
        printf("Invalid vector format: %s\n", err.what());
    }
}
```

Тут надо аккуратно уничтожить все векторы. Язык это и сделает: при выходе из блока (в т.ч. функции) уничтожает все локальные переменные. Это называется "раскрутка стэка" (stack unwinding).

При этом char *x утечёт, как обычно. Мораль: используйте деструкторы, как в std::vector. Или надо ловить вообще все исключения, а потом аккуратно разбираться, кого надо почистить, это неприятно.

### Идиома Resource Acquisition Is Initialization (RAII)

Если кончилась память в момент выделения вектора, вылетит стандартное исключение std::bad_alloc.

И вектор нельзя будет использовать. Даже синтаксически:

```c++
try {
    std::vector<int> a(1000000);
    ...
} catch (std::bad_alloc&) {
    ...
}
```

Наконец, расшифровка RAII: resource acquisition is initialization. Конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах. А если не смог — кидаем исключение.

### Примеры исключений из стандартной библиотеки (std::exception и его наследники, bad_alloc)


    * UB и деление на ноль не кидают ничего. В Java есть специальный NullPointerException и ArithmeticException, но что с ними делать — вообще неясно.
    * std::exception — базовый класс для всех из STL (обычно свои тоже к нему приписывают). Реализует virtual const char *what() const.
        * std::logic_error — условно "ошибки программиста". Здесь std::invalid_argument, std::out_of_range и ещё.
        * std::runtime_error — условно "ошибки окружения". Есть наследник std::system_error, а у него наследник ios_base::failure (ошибки ввода-вывода).
    * new Foo() кидает std::bad_alloc, если не удалось выделить память. Но что с ним делать?
    * vector::at кидает std::out_of_range. Но что с ним делать?
    * std::stoi кидает std::invalid_argument (не число) или std::out_of_range (число не влезет).
    * <iostream> не кидает по умолчанию (надо проверять флаги), но можно включить режим.

Можно добавлять свои классы, а дальше ловить:

```c++
struct Foo {};
struct Bar : Foo {};
...
try {
} catch (Bar &err) {
} catch (Foo &err) {
} catch (std::exception &e) {
}
```
* catch (...) Ловит исключения любого типа, проанализировать текущее нельзя. Но можно перекинуть: throw; (работает в любом блоке). Всё ещё не ловит деление на ноль и прочие UB!
